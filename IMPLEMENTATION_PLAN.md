# Implementation Plan

> Generated by planning phase. VLC 4.x API version: 4.0.6

## Current Goal - VIDEO FRAME OVERLAY

**Overlay .NET runtime debug info on each video frame.**

Display a semi-transparent box at top-left corner showing:
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Hello from .NET 8.0 ðŸŸ£     â”‚
â”‚  Frame: 1247                â”‚
â”‚  GC0: 12  Heap: 4.2 MB      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Success Criteria
- [ ] Video filter plugin loads in VLC 4
- [ ] Filter activates via `--video-filter=dotnet_overlay`
- [ ] Overlay visible on video frames
- [ ] Frame counter increments each frame
- [ ] GC stats update in real-time
- [ ] No visible stutter on 1080p video

---

## CRITICAL FINDINGS (From Failed Attempt)

The initial implementation failed because:

1. **Filter never instantiated**: VLC lists the filter (`--list` works) but the video output chain never calls our `Open()` function
2. **No verification mechanism**: Used `Console.Error.WriteLine()` which may not appear; no file-based proof of execution
3. **Format validation missing**: VLC filters must validate chroma formats via `vlc_fourcc_GetChromaDescription()` or VLC skips them
4. **VLC 4.x filter chain**: Video filters are instantiated by vout (video output), not at startup. Filter only loads when video plays AND format matches

### Finding from Phase 10 Testing (2026-01-26)
- **Filter Open() IS being called** - confirmed via debug file
- **DX11 opaque format**: Windows hardware-accelerated decoding produces `chroma=0x31315844 (DX11)`
- **GPU textures have 0 planes**: Cannot directly access pixel data
- **Solution needed**: Either request software decoding (`--avcodec-hw=none`) or handle D3D11 textures

### Finding from Phase 11-13 Testing (2026-01-26)
- **Software decoding required for CPU-accessible frames**: Use `--no-hw-dec`
- **I420 (YUV 4:2:0) format received**: 3 planes (Y, U, V)
- **ImageSharp overlay rendering works**: PNG saved successfully
- **Current Y-plane-only compositing**: Overlay appears as grayscale on video
- **VLC 4.x option change**: `--avcodec-hw=none` is obsolete, use `--no-hw-dec`
- **VLC command-line issue from Git Bash**: Running VLC with arguments from Git Bash may not pass file paths correctly. Use batch scripts or cmd.exe directly for testing.

### Files Already Created (Need Fixes)
- `src/glue/video_filter_entry.c` - C glue, needs format validation and debug output
- `src/VlcPlugin/FilterExports.cs` - C# exports, exists
- `src/VlcPlugin/FilterState.cs` - State management, exists
- `src/VlcPlugin/OverlayRenderer.cs` - ImageSharp renderer, exists
- `src/VlcPlugin/Resources/JetBrainsMono-Regular.ttf` - Font, exists

### VlcPlugin.csproj Already Has
- SixLabors.ImageSharp 3.1.12
- SixLabors.ImageSharp.Drawing 2.1.7
- SixLabors.Fonts 2.1.3
- Embedded font resource

---

## Architecture

```
VLC 4.x Plugin System
        â”‚
        â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â–¼                                    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  libdotnet_bridge_plugin â”‚    â”‚  libdotnet_filter_plugin   â”‚
â”‚  capability: "interface" â”‚    â”‚  capability: "video filter"â”‚
â”‚  plugins/control/        â”‚    â”‚  plugins/video_filter/     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚                                    â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚ Both load same VlcPlugin.dll
                      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  VlcPlugin.dll (Native AOT)                              â”‚
â”‚  - DotNetPluginOpen/Close (interface plugin)             â”‚
â”‚  - DotNetFilterOpen/Close/Frame (video filter plugin)    â”‚
â”‚  - ImageSharp text rendering                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Deployment Target

```
vlc-4.0.0-dev/
â”œâ”€â”€ vlc.exe
â”œâ”€â”€ libvlccore.dll
â””â”€â”€ plugins/
    â”œâ”€â”€ control/
    â”‚   â”œâ”€â”€ libdotnet_bridge_plugin.dll   â† Interface plugin (existing)
    â”‚   â””â”€â”€ VlcPlugin.dll                 â† C# Native AOT (shared)
    â””â”€â”€ video_filter/
        â”œâ”€â”€ libdotnet_filter_plugin.dll   â† Video filter plugin
        â””â”€â”€ VlcPlugin.dll                 â† Copy of C# DLL (for DLL loading)
```

---

## Phase 10: Video Filter - Verify Open Is Called (REVISED)

**Goal**: Prove the C `Open()` callback is invoked by VLC's video output chain.

### Problem Analysis
VLC seeing filter in `--list` does NOT mean the filter is used. The video output (vout) decides whether to instantiate filters based on:
- Video format compatibility
- Filter chain configuration
- Whether video is actually playing

### Tasks
- [x] File exists: `src/glue/video_filter_entry.c`
- [x] **Add file-based debug proof in C `Open()` callback**
- [x] **Add proper format validation**
- [x] **Use msg_Info for VLC logging**
- [x] Rebuild
- [x] Redeploy
- [x] Regenerate plugin cache
- [x] Test

### Acceptance Criteria
- [x] File `C:\temp\dotnet_filter_open.txt` is created when playing video
- [x] Filter `Open()` is called by VLC's vout chain
- Note: chroma format 0x31315844 (DX11) received - GPU opaque texture

### Debugging If Open Not Called
1. Check VLC verbose log for "looking for video filter" messages
2. Compare our module descriptor to working VLC filters (invert.c, mirror.c)
3. Try forcing a specific vout: `--vout=direct3d11` or `--vout=opengl`
4. Check if filter is rejected due to format: add logging before format check

---

## Phase 11: Minimal Frame Modification (No ImageSharp)

**Goal**: Prove we can modify video frame pixels without any .NET complexity.

### DX11 Hardware Decoding Issue
Phase 10 revealed that Windows hardware-accelerated decoding produces DX11 opaque textures (`chroma=0x31315844`) with 0 accessible planes. We cannot directly access pixel data from GPU textures.

### Approach
1. **First**: Test with software decoding to get CPU-accessible pixel formats:
   ```bash
   vlc --no-hw-dec --video-filter=dotnet_overlay video.mp4
   ```
   Note: VLC 4.x uses `--no-hw-dec` (not `--avcodec-hw=none` which is deprecated)
2. **If software decoding works** with RGB/YUV formats, proceed with overlay rendering
3. **If filter needs to work with hardware decoding**, we need D3D11 texture handling (significantly more complex - requires DirectX interop)

### VLC 4.x Hardware Decoding Behavior (Found 2026-01-26)
- `--no-hw-dec` disables hardware decoders but the video output still uses D3D11
- The filter chain is created BEFORE format negotiation completes
- Our filter receives DX11 opaque format even with `--no-hw-dec`
- **Solution**: Need to implement `b_allow_fmt_out_change` in Open() to request software conversion

### Rationale
Remove all complexity (ImageSharp, fonts, C# frame processing) and just write a solid color rectangle directly in C. This isolates whether the problem is in the filter chain or in the .NET integration.

### Tasks
- [x] Test with software decoding: `vlc --no-hw-dec --video-filter=dotnet_overlay video.mp4`
- [x] Verify we receive a format with accessible planes (I420 received, 3 planes)
- [ ] In C `Filter()` callback, write a red rectangle directly:
  ```c
  static picture_t *Filter(filter_t *filter, picture_t *pic) {
      // Log every 100 frames
      static int frame_count = 0;
      if (++frame_count % 100 == 0)
          msg_Info(filter, ".NET Overlay: Frame %d", frame_count);

      picture_t *out = filter_NewPicture(filter);
      if (!out) {
          picture_Release(pic);
          return NULL;
      }

      picture_Copy(out, pic);

      // Draw red rectangle at top-left (for RGB32/BGRA formats)
      if (out->i_planes > 0) {
          uint8_t *pixels = out->p[0].p_pixels;
          int pitch = out->p[0].i_pitch;
          // Draw 100x50 red box
          for (int y = 10; y < 60 && y < out->p[0].i_visible_lines; y++) {
              uint32_t *row = (uint32_t*)(pixels + y * pitch);
              for (int x = 10; x < 110 && x < out->p[0].i_visible_pitch/4; x++) {
                  row[x] = 0xFFFF0000; // ARGB red
              }
          }
      }

      picture_CopyProperties(out, pic);
      picture_Release(pic);
      return out;
  }
  ```
- [ ] Test with VLC - should see red rectangle on video
- [ ] If works: proceed to Phase 12 (add .NET calls)
- [ ] If doesn't work: debug filter_NewPicture, picture format, etc.

### Acceptance Criteria
- [x] Red rectangle visible on playing video (grayscale Y-plane modification working)
- [x] Frame count logged every 100 frames (confirmed: 100, 200, 300, 400)
- Note: Current implementation overlays on Y plane only - shows as grayscale

---

## Phase 12: Add .NET Callback (Simple Test)

**Goal**: Call into C# from the filter and verify it works.

### Tasks
- [ ] In C `Filter()`, call `DotNetFilterFrame()` after the red box test works
- [ ] In C# `FilterExports.ProcessFrame()`, write to a debug file:
  ```csharp
  if (frameCount == 1) {
      File.WriteAllText(@"C:\temp\dotnet_filter_frame.txt",
          $"Frame 1 processed at {DateTime.Now}");
  }
  ```
- [ ] Verify file is created when video plays

### Acceptance Criteria
- [ ] `C:\temp\dotnet_filter_frame.txt` created
- [ ] Both C and C# code executing per-frame

---

## Phase 13: ImageSharp Overlay Rendering

**Goal**: Use ImageSharp to render the debug text overlay.

### Tasks
- [x] Verify `OverlayRenderer.cs` loads font from embedded resource
- [x] Render overlay to RGBA buffer
- [x] Save first frame's overlay to `C:\temp\overlay_test.png`
- [x] Verify PNG contains expected text

### Acceptance Criteria
- [x] `C:\temp\overlay_test.png` created with readable text
- [x] No exceptions during font loading or text rendering

---

## Phase 14: Frame Compositing

**Goal**: Composite the ImageSharp overlay onto video frames.

### Tasks
- [ ] Pass overlay RGBA bytes from C# back to C
- [ ] Composite overlay onto video frame with alpha blending
- [ ] Handle different pixel formats (BGRA, RGBA, RGB24)
- [ ] Position overlay at (10, 10)

### Acceptance Criteria
- [ ] Debug overlay visible on video in VLC Qt application
- [ ] Frame counter increments
- [ ] GC stats update

---

## Phase 15: Format Negotiation (If Needed)

**Goal**: Handle YUV video formats.

### Tasks
- [ ] If video is YUV (I420, NV12), request RGB conversion
- [ ] Set `filter->b_allow_fmt_out_change = true`
- [ ] Test with various video formats

### Acceptance Criteria
- [ ] Works with common video files (H.264, etc.)

---

## Completed Phases (Phases 1-9)

### Phase 1: Minimal Viable Plugin âœ“
C# Native AOT project with `[UnmanagedCallersOnly]` exports, C glue layer with VLC module macros, and bridge integration.

### Phase 2: Real VLC Integration âœ“
Linked against real libvlccore.dll, deployed to VLC plugins/control/, verified logging works.

### Phase 3: Player Events Integration âœ“
Player state/position/media change events via vlc_player_AddListener. C# VlcPlayer wrapper class.

### Phase 4: Playlist Control âœ“
Full playlist control: start/stop/pause/resume, next/prev, goto, count, current index. C# VlcPlaylist wrapper.

### Phase 5: Unit Testing âœ“
xUnit test project covering UTF-8 marshalling and API contract verification. 94 tests passing.

### Phase 6: Object Management âœ“
VlcObject wrapper class with object hierarchy navigation (parent, typename, root traversal).

### Phase 7: Binding Documentation âœ“
Created Generated/ directory with VlcTypes.cs, VlcConstants.cs, and documentation.

### Phase 8: Player Seeking and Playback Control âœ“
Extended VlcPlayer with seeking functionality. 25 new unit tests.

### Phase 9: Audio Volume Control âœ“
Extended VlcPlayer with audio volume control. 8 new unit tests.

---

## Build Commands

### C# Native AOT
```bash
export PATH="$PATH:/c/Program Files (x86)/Microsoft Visual Studio/Installer"
dotnet publish src/VlcPlugin -c Release -r win-x64
```

### C Glue (Video Filter)
```bash
# Compile
"C:/Program Files/LLVM/bin/clang.exe" -c -o build/video_filter_entry.o src/glue/video_filter_entry.c -I./vlc/include

# Link (uses vlccore.lib with picture_* exports)
"C:/Program Files/LLVM/bin/clang.exe" -shared -o build/libdotnet_filter_plugin.dll build/video_filter_entry.o -L./build -lvlccore

# Deploy
cp build/libdotnet_filter_plugin.dll vlc-binaries/vlc-4.0.0-dev/plugins/video_filter/
cp src/VlcPlugin/bin/Release/net10.0/win-x64/native/VlcPlugin.dll vlc-binaries/vlc-4.0.0-dev/plugins/video_filter/

# Regenerate cache
vlc-binaries/vlc-4.0.0-dev/vlc-cache-gen.exe vlc-binaries/vlc-4.0.0-dev/plugins
```

### Test
```bash
vlc-binaries/vlc-4.0.0-dev/vlc.exe --video-filter=dotnet_overlay "C:/Users/Martin/Videos/BigBuckBunny.mp4"
# Check: C:\temp\dotnet_filter_open.txt
```

---

## Dependencies

- **SixLabors.ImageSharp** (3.1.12) - Image manipulation, Native AOT compatible
- **SixLabors.ImageSharp.Drawing** (2.1.7) - Text drawing
- **SixLabors.Fonts** (2.1.3) - Font loading and text rendering
- **JetBrains Mono** (embedded TTF) - Monospace font for overlay

---

## Learnings

1. **vswhere.exe requirement**: Need in PATH for native AOT publish
2. **vlccore stub**: `vlccore_stub.c` provides stub for testing without VLC
3. **Variadic functions**: VLC logging uses variadic functions - wrap in C glue
4. **Circular dependency**: C# cannot DirectPInvoke to C glue that loads it; use runtime resolution
5. **Import library generation**: Use `llvm-dlltool -d vlccore.def -l vlccore.lib -m i386:x86-64`
6. **DLL path resolution**: Use GetModuleHandleEx + GetModuleFileName for plugin directory
7. **Plugin cache**: Run `vlc-cache-gen.exe plugins` after updating plugins
8. **CRT heap incompatibility**: VLC (mingw/msvcrt) and plugin (UCRT) use different heaps
9. **vlc_player_cbs structure**: Must match vlc_player.h callback order exactly
10. **Playlist locking**: Playlist and player share the same lock
11. **vlc_object_find_name deprecated**: Not exported in VLC 4.x
12. **Type definition separation**: Keep types in VlcPlugin.Generated namespace only
13. **Audio output functions don't require lock**: vlc_player_aout_* functions work without player lock
14. **Video filter discovery vs activation**: `vlc --list` showing a filter does NOT mean it will be used. The vout (video output) decides whether to instantiate filters based on format compatibility.
15. **Format validation required**: Filters must validate chroma via `vlc_fourcc_GetChromaDescription()` or VLC may skip them silently.
16. **Debug with files, not console**: Use file-based proof (`fopen`/`fwrite`) to verify code paths are hit, since stderr/console output may be redirected or lost.
17. **POSIX types on Windows**: VLC headers need `ssize_t` and `off_t` defined before including `vlc_filter.h` on Windows.
18. **DX11 opaque textures**: Windows hardware-accelerated decoding (D3D11VA) produces `chroma=0x31315844 (DX11)` with 0 accessible planes. Cannot directly write to GPU textures.
19. **VLC 4.x hw-dec option**: Use `--no-hw-dec` to disable hardware decoders (not `--avcodec-hw=none` which is deprecated).
20. **VLC 4.x filter lifecycle**: Filter Open() receives format from vout chain. Even with `--no-hw-dec`, vout may still use D3D11 output requiring format conversion.
21. **QT interface doesn't auto-play**: VLC 4.x with QT interface doesn't auto-start command-line media; use `--qt-start-minimized` and wait for playlist to start.
22. **VLC 4.x hardware decoding option**: Use `--no-hw-dec` (not `--avcodec-hw=none` which is obsolete)
23. **Git Bash + VLC file arguments**: VLC may not receive file paths correctly when launched from Git Bash. Use `cmd.exe /c` or batch scripts.
24. **I420 format for software decoding**: VLC uses I420 (planar YUV 4:2:0) when hardware decoding is disabled

---

## References

- VLC video filter examples: `vlc/modules/video_filter/invert.c`, `mirror.c`, `adjust.c`
- VLC filter API: `vlc/include/vlc_filter.h`
- VLC picture API: `vlc/include/vlc_picture.h`
- VLC 4.x API version: 4.0.6
- ImageSharp docs: https://docs.sixlabors.com/
- Spec: `specs/video-frame-overlay.md`
